# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculate the highest-value EB Negbin loglihood ratio statistic.
#'
#' Calculate the expectation-based ZIP loglihood ratio statistic for each zone
#' and duration, but only keep the zone and duration with the highest value
#' (the MLC). The estimate of the relative risk is also calculated, along with
#' the number of iterations the EM algorithm performed.
#' @param counts matrix (most recent timepoint in first row)
#' @param baselines matrix (most recent timepoint in first row)
#' @param overdisp matrix (most recent timepoint in first row)
#' @param zones integer vector (all zones concatenated; locations indexed from
#'    0 and up)
#' @param zone_lengths integer vector
#' @param store_everything boolean
#' @param num_mcsim int
#' @param score_hotspot boolean
#' @return A list with elements \code{observed} and \code{simulated}, each 
#'    being a data frame with columns:
#'    \describe{
#'      \item{zone}{The top-scoring zone (spatial component of MLC).}
#'      \item{duration}{The corresponding duration (time-length of MLC).}
#'      \item{score}{The value of the loglihood ratio statistic (the scan
#'                   statistic).}
#'      \item{relrisk}{The estimated relative risk.}
#'      \item{n_iter}{The number of iterations performed by the EM algorithm.}
#'    }
#' @export
#' @keywords internal
scan_eb_negbin_cpp <- function(counts, baselines, overdisp, zones, zone_lengths, store_everything, num_mcsim, score_hotspot) {
    .Call(`_scanstatistics_scan_eb_negbin_cpp`, counts, baselines, overdisp, zones, zone_lengths, store_everything, num_mcsim, score_hotspot)
}

#' Calculate the highest-value EB ZIP loglihood ratio statistic.
#'
#' Calculate the expectation-based ZIP loglihood ratio statistic for each zone
#' and duration, but only keep the zone and duration with the highest value
#' (the MLC). The estimate of the relative risk is also calculated, along with
#' the number of iterations the EM algorithm performed.
#' @param counts matrix (most recent timepoint in first row)
#' @param baselines matrix (most recent timepoint in first row)
#' @param zones integer vector (all zones concatenated; locations indexed from
#'    0 and up)
#' @param zone_lengths integer vector
#' @param store_everything boolean
#' @param num_mcsim int
#' @return A list with elements \code{observed} and \code{simulated}, each 
#'    being a data frame with columns:
#'    \describe{
#'      \item{zone}{The top-scoring zone (spatial component of MLC).}
#'      \item{duration}{The corresponding duration (time-length of MLC).}
#'      \item{score}{The value of the loglihood ratio statistic (the scan
#'                   statistic).}
#'      \item{relrisk_in}{The estimated relative risk inside.}
#'      \item{relrisk_in}{The estimated relative risk outside.}
#'    }
#' @export
#' @keywords internal
scan_eb_poisson_cpp <- function(counts, baselines, zones, zone_lengths, store_everything, num_mcsim) {
    .Call(`_scanstatistics_scan_eb_poisson_cpp`, counts, baselines, zones, zone_lengths, store_everything, num_mcsim)
}

#' Calculate the highest-value EB ZIP loglihood ratio statistic.
#'
#' Calculate the expectation-based ZIP loglihood ratio statistic for each zone
#' and duration, but only keep the zone and duration with the highest value
#' (the MLC). The estimate of the relative risk is also calculated, along with
#' the number of iterations the EM algorithm performed.
#' @param counts matrix (most recent timepoint in first row)
#' @param baselines matrix (most recent timepoint in first row)
#' @param probs matrix (most recent timepoint in first row)
#' @param zones integer vector (all zones concatenated; locations indexed from
#'    0 and up)
#' @param zone_lengths integer vector
#' @param rel_tol double
#' @param store_everything boolean
#' @param num_mcsim int
#' @return A list with elements \code{observed} and \code{simulated}, each 
#'    being a data frame with columns:
#'    \describe{
#'      \item{zone}{The top-scoring zone (spatial component of MLC).}
#'      \item{duration}{The corresponding duration (time-length of MLC).}
#'      \item{score}{The value of the loglihood ratio statistic (the scan
#'                   statistic).}
#'      \item{relrisk}{The estimated relative risk.}
#'      \item{n_iter}{The number of iterations performed by the EM algorithm.}
#'    }
#' @export
#' @keywords internal
scan_eb_zip_cpp <- function(counts, baselines, probs, zones, zone_lengths, rel_tol, store_everything, num_mcsim) {
    .Call(`_scanstatistics_scan_eb_zip_cpp`, counts, baselines, probs, zones, zone_lengths, rel_tol, store_everything, num_mcsim)
}

#' Calculate the highest-value EB ZIP loglihood ratio statistic.
#'
#' Calculate the expectation-based ZIP loglihood ratio statistic for each zone
#' and duration, but only keep the zone and duration with the highest value
#' (the MLC). The estimate of the relative risk is also calculated, along with
#' the number of iterations the EM algorithm performed.
#' @param counts matrix (most recent timepoint in first row)
#' @param baselines matrix (most recent timepoint in first row)
#' @param zones integer vector (all zones concatenated; locations indexed from
#'    0 and up)
#' @param zone_lengths integer vector
#' @param store_everything boolean
#' @param num_mcsim int
#' @return A list with elements \code{observed} and \code{simulated}, each 
#'    being a data frame with columns:
#'    \describe{
#'      \item{zone}{The top-scoring zone (spatial component of MLC).}
#'      \item{duration}{The corresponding duration (time-length of MLC).}
#'      \item{score}{The value of the loglihood ratio statistic (the scan
#'                   statistic).}
#'      \item{relrisk_in}{The estimated relative risk inside.}
#'      \item{relrisk_in}{The estimated relative risk outside.}
#'    }
#' @export
#' @keywords internal
scan_pb_poisson_cpp <- function(counts, baselines, zones, zone_lengths, store_everything, num_mcsim) {
    .Call(`_scanstatistics_scan_pb_poisson_cpp`, counts, baselines, zones, zone_lengths, store_everything, num_mcsim)
}

#' Get indices of zero elements in a vector.
#' @param v An integer vector.
#' @return A vector with the indices of elements equal to zero in \code{v}.
#'    Indices start at zero.
#' @keywords internal
#' @export
get_zero_indices <- function(v) {
    .Call(`_scanstatistics_get_zero_indices`, v)
}

