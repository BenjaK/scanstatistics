# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculate the expectation-based negative binomial scan statistic.
#'
#' Calculate the expectation-based negative binomial scan statistic and Monte
#' Carlo replicates.
#' @param counts Integer matrix (most recent timepoint in first row)
#' @param baselines Matrix (most recent timepoint in first row)
#' @param overdisp Matrix (most recent timepoint in first row)
#' @param zones Integer vector (all zones concatenated; locations indexed from
#'    0 and up)
#' @param zone_lengths Integer vector
#' @param store_everything Boolean
#' @param num_mcsim Integer
#' @param score_hotspot Boolean
#' @return A list with elements \code{observed} and \code{simulated}, each 
#'    being a data frame with columns:
#'    \describe{
#'      \item{zone}{The top-scoring zone (spatial component of MLC).}
#'      \item{duration}{The corresponding duration (time-length of MLC).}
#'      \item{score}{The value of the loglihood ratio statistic (the scan
#'                   statistic).}
#'      \item{relrisk}{The estimated relative risk.}
#'      \item{n_iter}{The number of iterations performed by the EM algorithm.}
#'    }
#' @export
#' @keywords internal
scan_eb_negbin_cpp <- function(counts, baselines, overdisp, zones, zone_lengths, store_everything, num_mcsim, score_hotspot) {
    .Call(`_scanstatistics_scan_eb_negbin_cpp`, counts, baselines, overdisp, zones, zone_lengths, store_everything, num_mcsim, score_hotspot)
}

#' Calculate the expecation-based Poisson scan statistic.
#' 
#' Calculate the expectation-based Poisson scan statistic and Monte Carlo 
#' replicates.
#' @param counts An integer matrix (most recent timepoint in first row).
#' @param baselines A matrix with positive entries (most recent timepoint in 
#'    first row).
#' @param zones An integer vector (all zones concatenated; locations indexed 
#'    from 0 and up).
#' @param zone_lengths An integer vector.
#' @param store_everything A boolean.
#' @param num_mcsim An integer.
#' @return A list with elements \code{observed} and \code{simulated}, each 
#'    being a data frame with columns:
#'    \describe{
#'      \item{zone}{The top-scoring zone (spatial component of MLC).}
#'      \item{duration}{The corresponding duration (time-length of MLC).}
#'      \item{score}{The value of the loglihood ratio statistic (the scan
#'                   statistic).}
#'      \item{relrisk_in}{The estimated relative risk inside.}
#'      \item{relrisk_in}{The estimated relative risk outside.}
#'    }
#' @export
#' @keywords internal
scan_eb_poisson_cpp <- function(counts, baselines, zones, zone_lengths, store_everything, num_mcsim) {
    .Call(`_scanstatistics_scan_eb_poisson_cpp`, counts, baselines, zones, zone_lengths, store_everything, num_mcsim)
}

#' Calculate the highest-value EB ZIP loglihood ratio statistic.
#'
#' Calculate the expectation-based ZIP loglihood ratio statistic for each zone
#' and duration, but only keep the zone and duration with the highest value
#' (the MLC). The estimate of the relative risk is also calculated, along with
#' the number of iterations the EM algorithm performed.
#' @param counts matrix (most recent timepoint in first row)
#' @param baselines matrix (most recent timepoint in first row)
#' @param probs matrix (most recent timepoint in first row)
#' @param zones integer vector (all zones concatenated; locations indexed from
#'    0 and up)
#' @param zone_lengths integer vector
#' @param rel_tol double
#' @param store_everything boolean
#' @param num_mcsim int
#' @return A list with elements \code{observed} and \code{simulated}, each 
#'    being a data frame with columns:
#'    \describe{
#'      \item{zone}{The top-scoring zone (spatial component of MLC).}
#'      \item{duration}{The corresponding duration (time-length of MLC).}
#'      \item{score}{The value of the loglihood ratio statistic (the scan
#'                   statistic).}
#'      \item{relrisk}{The estimated relative risk.}
#'      \item{n_iter}{The number of iterations performed by the EM algorithm.}
#'    }
#' @export
#' @keywords internal
scan_eb_zip_cpp <- function(counts, baselines, probs, zones, zone_lengths, rel_tol, store_everything, num_mcsim) {
    .Call(`_scanstatistics_scan_eb_zip_cpp`, counts, baselines, probs, zones, zone_lengths, rel_tol, store_everything, num_mcsim)
}

#' Calculate the space-time permutation scan statistic.
#'
#' Calculate the space-time permutation scan statistic (Kulldorff 2005) and 
#' Monte Carloo  replicates.
#' @param counts An integer matrix (most recent timepoint in first row).
#' @param baselines A matrix with positive entries (most recent timepoint in 
#'    first row).
#' @param zones An integer vector (all zones concatenated; locations indexed 
#'    from 0 and up)
#' @param zone_lengths An integer vector.
#' @param store_everything A boolean.
#' @param num_mcsim An integer.
#' @return A list with elements \code{observed} and \code{simulated}, each 
#'    being a data frame with columns:
#'    \describe{
#'      \item{zone}{The top-scoring zone (spatial component of MLC).}
#'      \item{duration}{The corresponding duration (time-length of MLC).}
#'      \item{score}{The value of the loglihood ratio statistic (the scan
#'                   statistic).}
#'      \item{relrisk_in}{The estimated relative risk inside.}
#'      \item{relrisk_in}{The estimated relative risk outside.}
#'    }
#' @export
#' @keywords internal
scan_pb_perm_cpp <- function(counts, baselines, zones, zone_lengths, store_everything, num_mcsim) {
    .Call(`_scanstatistics_scan_pb_perm_cpp`, counts, baselines, zones, zone_lengths, store_everything, num_mcsim)
}

#' Calculate the population-based Poisson scan statistic.
#'
#' Calculate the population-based Poisson scan statistic and Monte Carlo 
#' replicates.
#' @param counts integer matrix (most recent timepoint in first row)
#' @param baselines matrix (most recent timepoint in first row)
#' @param zones integer vector (all zones concatenated; locations indexed from
#'    0 and up)
#' @param zone_lengths integer vector
#' @param store_everything boolean
#' @param num_mcsim int
#' @return A list with elements \code{observed} and \code{simulated}, each 
#'    being a data frame with columns:
#'    \describe{
#'      \item{zone}{The top-scoring zone (spatial component of MLC).}
#'      \item{duration}{The corresponding duration (time-length of MLC).}
#'      \item{score}{The value of the loglihood ratio statistic (the scan
#'                   statistic).}
#'      \item{relrisk_in}{The estimated relative risk inside.}
#'      \item{relrisk_in}{The estimated relative risk outside.}
#'    }
#' @export
#' @keywords internal
scan_pb_poisson_cpp <- function(counts, baselines, zones, zone_lengths, store_everything, num_mcsim) {
    .Call(`_scanstatistics_scan_pb_poisson_cpp`, counts, baselines, zones, zone_lengths, store_everything, num_mcsim)
}

#' Get indices of zero elements in a vector.
#' @param v An integer vector.
#' @return A vector with the indices of elements equal to zero in \code{v}.
#'    Indices start at zero.
#' @keywords internal
#' @export
get_zero_indices <- function(v) {
    .Call(`_scanstatistics_get_zero_indices`, v)
}

expand_matrix <- function(A) {
    .Call(`_scanstatistics_expand_matrix`, A)
}

contract_matrix <- function(A, nr, nc) {
    .Call(`_scanstatistics_contract_matrix`, A, nr, nc)
}

shuffle_time_counts <- function(v) {
    .Call(`_scanstatistics_shuffle_time_counts`, v)
}

#' Permute the entries of the matrix, preserving row and column marginals.
#' 
#' Permute the entries of the matrix, preserving row and column marginals.
#' @param A An integer matrix.
#' @return An integer matrix.
#' @keywords internal
permute_matrix <- function(A) {
    .Call(`_scanstatistics_permute_matrix`, A)
}

